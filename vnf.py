from nbi import kafka_proto_interface as kafka_interface
from db.db import DB
from omci_logger import OmciLogger
from database.onu_management_chain import ManagementChain
from database.telemetry_subscription import Subscription
import threading, json, time

logger = OmciLogger.getLogger(__name__)

import os
DEFAULT_BOOTSTRAP_SERVERS = list(os.environ.get('KAFKA_BOOTSTRAP_SERVER', "kafka:9092 localhost:9092").split())
GRPC_SERVER_NAME = os.getenv("GRPC_SERVER_NAME")
LOCAL_GRPC_SERVER_PORT = os.getenv("LOCAL_GRPC_SERVER_PORT", default=8433)
REMOTE_GRPC_SERVER_PORT = os.getenv("REMOTE_GRPC_SERVER_PORT", default=58433)
REMOTE_GRPC_SERVER_ADDR = os.getenv("REMOTE_GRPC_SERVER_ADDR")
KAFKA_REQUEST_TOPICS = list(os.environ.get('KAFKA_REQUEST_TOPICS').split())
KAFKA_RESPONSE_TOPICS = list(os.environ.get('KAFKA_RESPONSE_TOPICS').split())
KAFKA_NOTIFICATION_TOPICS = list(os.environ.get('KAFKA_NOTIFICATION_TOPICS').split())

class VNF:
    """ A parent class to handle identical behaviour of vomci function and vomci proxy"""
    def __init__(self, db_location: str, name: str):
        self._name = name
        self._kafka_if = None
        self._key_map = {}
        self._server = None
        self._kafka_thread = None
        self._upstream_conn = dict()  # contains all upstream client connections
        self._downstream_conn = dict()  # contains all downstream client connections
        self._db = DB(db_location)

    def start(self, local_endpoint_name = None, bootstrap_servers = None):
        self._kafka_if = kafka_interface.KafkaProtoInterface(local_endpoint_name, self, bootstrap_servers)

        configuration = self._db.get_configuration(self._name)
        #load configuration if it exists
        if configuration is not None:
            logger.info("stored configuration found for vnf: {}".format(self._name))
            self.setup_state(configuration)
        #or use defauls
        else:
            # logger.info("no configuration found for {}, starting with defaults..".format(self._name))
            # self._kafka_thread = threading.Thread(name='kafka_vomci_thread', target=self._kafka_if.start)
            # self._kafka_thread.start()

            custom_state = {}
            custom_state['bootstrap_servers'] = DEFAULT_BOOTSTRAP_SERVERS
            custom_state['production_topics'] = KAFKA_RESPONSE_TOPICS
            custom_state['notification_topics'] = KAFKA_NOTIFICATION_TOPICS
            custom_state['consumption_topics'] = KAFKA_REQUEST_TOPICS
            custom_state['grpc_servers'] = [{'name':GRPC_SERVER_NAME, 'adress':'::', 'port':LOCAL_GRPC_SERVER_PORT}]
            custom_state['grpc_upstream_connections'] = []
            if REMOTE_GRPC_SERVER_ADDR is not None:
                adress = "{}:{}".format(REMOTE_GRPC_SERVER_ADDR, REMOTE_GRPC_SERVER_PORT)
                custom_state['grpc_upstream_connections'] = [{self._name:adress}]
            custom_state['onus'] = []
            custom_state['telemetry_subscriptions'] = json.dumps({})
            self.setup_state(json.dumps(custom_state))
        
        # wait fot thread to finish
        self._kafka_thread.join()

    def export_state(self) -> str:
        """Returns a json with the state of the VService"""
        state = {}
        state['bootstrap_servers'] = self._kafka_if._bootstrap_servers
        state['production_topics'] = self._kafka_if._producer._topics
        state['notification_topics'] = self._kafka_if._producer._notification_topics
        state['consumption_topics'] = self._kafka_if._consumer._topics
        
        state['grpc_servers'] = []
        if self._server is not None:
            state['grpc_servers'] = [{'name':self._server._name, 'adress':self._server._adress, 'port':self._server._port}]
        
        state['grpc_upstream_connections'] = []
        for access_point in self._upstream_conn:
            state['grpc_upstream_connections'].append({access_point:self._upstream_conn[access_point]._adress})
    
        state['telemetry_subscriptions'] = Subscription.export_subscriptions()
        
        state['onus'] = []
        onus = ManagementChain.GetManagedOnus()
        for onu in onus:
            onuconf = {"onu_name": onu.onu_name, "is_configured": onu.is_configured}
            if onu.is_configured:
                onuconf['olt_name'] = onu.olt_name
                onuconf['channel_termination'] = onu.ct_ref
                onuconf['onu_tc_id'] = onu.onu_id
                onuconf['available'] = onu.communication_available
                onuconf['olt_endpoint_name'] = onu.downstream_endpoint_name
                onuconf['south_endpoint_name'] = onu.upstream_endpoint_name
                onuconf['sender_name'] = onu.voltmf_name

            state['onus'].append(onuconf)
        return json.dumps(state)

    def setup_state(self, state: str):
        """
            Gets a state generated by 'export_state' and 
            applies it to all configurable parameters.
            If state is none, defaults will be used.
            Creates a thread to run kafka.
        """
        state = json.loads(state)
        logger.debug('attempting to setup with state: {}'.format(state))
        myargs = [state['production_topics'], state['notification_topics'], state['consumption_topics']]
        grpc_servers = state['grpc_servers']
        grpc_upstream_connections = state['grpc_upstream_connections']
        onus = state['onus']
        telemetry_subscriptions = state['telemetry_subscriptions']

        self._kafka_thread = threading.Thread(name='kafka_vomci_thread', target=self._kafka_if.start, args=myargs)
        for server in grpc_servers:
            self.trigger_start_grpc_server(server['name'], server['adress'], server['port'])
        for conn in grpc_upstream_connections: #conn is of type {name:adress} and adress is "host:port"
            name = list(conn)[0]
            adress = conn[name]
            col_index = adress.rindex(":")
            host = adress[:col_index]
            port = adress[col_index+1:]
            self.trigger_create_grpc_connection(host, port)
        for onu in onus:
            self.trigger_create_onu(onu['onu_name'])
            if onu['is_configured']:
                self.trigger_set_onu_communication(onu['olt_name'], onu['onu_name'],
                        onu['channel_termination'], onu['onu_tc_id'], onu['available'], 
                        onu['olt_endpoint_name'], onu['south_endpoint_name'], onu['sender_name'])
        Subscription.import_subscriptions(telemetry_subscriptions)
        self._kafka_thread.start()

    def update_configuration_in_db(self):
        self._db.insert_configuration(self._name, self.export_state())
